const char* cl_render = "//\n// CL renderer\n// (C) 2012 K.Ohta <whatisthis.sowhat@gmail.com>\n// History: Nov 01,2012 Initial.\n// License: Apache License 2.0\n\n\n#if __ENDIAN_LITTLE__\n#define  rmask 0x000000ff\n#define  gmask 0x00ff0000\n#define  bmask 0x0000ff00\n#define  amask 0xff000000\n#define  rshift 0\n#define  gshift 16\n#define  bshift 8\n#define  ashift 24\n#else\n#define  amask 0x000000ff\n#define  bmask 0x00ff0000\n#define  gmask 0x0000ff00\n#define  rmask 0xff000000\n#define  rshift 24\n#define  gshift 8\n#define  bshift 16\n#define  ashift 0\n#endif\n\ninline uint8 putpixel(uint8 n, uint8 abuf)\n{\n  uint8 ret;\n  \n//  rmask8 = (uint8){rmask, rmask, rmask, rmask, rmask, rmask, rmask, rmask};\n//  gmask8 = (uint8){gmask, gmask, gmask, gmask, gmask, gmask, gmask, gmask};\n//  bmask8 = (uint8){bmask, bmask, bmask, bmask, bmask, bmask, bmask, bmask};\n//  rbuf = (n & rmask8);\n//  gbuf = (n & gmask8);\n//  bbuf = (n & bmask8);\n//  ret = (rbuf << rshift)  + (gbuf << gshift) + (bbuf << bshift) + (abuf << ashift); \n  ret = n | abuf;\n  return ret;\n}\n\n__kernel void getvram8(__global uchar *src, int w, int h, __global uchar4 *out,\n                       __global uint *pal, __global uint *table,\n		       int multithread)\n{\n  int ofset = 0x4000;\n  int x;\n  int y;\n  int hh;\n  int ww;\n  int xx;\n  int t;\n  int gid;\n  uint addr;\n  uint addr2;\n  uchar rc,bc,gc;\n  uint8 av;\n  uint8 abuf = (uint8){amask, amask, amask, amask, amask, amask, amask, amask};\n  uint8 palette;\n  __global uint8 *tbl8;\n  uint8 c8;\n  __global uint8 *p8;\n  uint pb1, pbegin, col;\n  __global uchar *src_r;\n  __global uchar *src_g;\n  __global uchar *src_b;\n\n  ww = w >> 3;\n  if(multithread != 0){\n      t = get_global_size(0);\n      gid = get_global_id(0);\n      col = ww * h;\n      pbegin = (gid * col) / t; \n      pb1 = ((gid + 1) * col) / t;\n      if(pb1 > col) {\n         ww = col - pbegin;\n      } else {\n         ww = pb1 - pbegin;\n      }\n      addr = pbegin; \n      addr2 = pbegin << 3;\n  } else {\n      addr = addr2 = 0;\n      ww = ww * h;\n  }\n  \n  p8 = (__global uint8 *)(&(out[addr2]));\n\n  palette = (uint8){pal[0], pal[1], pal[2], pal[3],\n                    pal[4], pal[5], pal[6], pal[7]};  \n//  palette.s0 = pal[0];\n//  palette.s1 = pal[1];\n//  palette.s2 = pal[2];\n//  palette.s3 = pal[3];\n//  palette.s4 = pal[4];\n//  palette.s5 = pal[5];\n//  palette.s6 = pal[6];\n//  palette.s7 = pal[7];\n  \n  if(h > 200) ofset = 0x8000;\n\n  tbl8 = (__global uint8 *)table;\n  //p = (__global uchar4 *)(&(out[addr2]));\n  p8 = (__global uint8 *)(&(out[addr2]));\n  src_r = &src[addr + ofset];\n  src_g = &src[addr + ofset + ofset];\n  src_b = &src[addr];\n  \n  prefetch(tbl8, 256 * 3);\n  prefetch(src_r, ww);\n  prefetch(src_g, ww);\n  prefetch(src_b, ww);\n  for(x = 0; x < ww; x++) {\n        bc = *src_b;\n	rc = *src_r;\n	gc = *src_g;\n        c8 = tbl8[bc] | tbl8[rc + 256] | tbl8[gc + 256 * 2];\n//	c8 &= (uint8){0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};\n	av = shuffle(palette, c8);\n	*p8 = putpixel(av, abuf);\n	p8++;\n        src_r++;\n        src_g++;\n        src_b++;\n	}\n}	\n	\n\n__kernel void getvram4096(__global uchar *src, int w, int h, \n                          __global uchar4 *out, __global uint *pal,\n			  __global uint *table,\n			  int multithread)\n{\n  int ofset = 0x8000;\n  int x;\n  int y;\n  int hh;\n  int ww;\n  int t;\n  int gid;\n  uint addr;\n  uint addr2;\n  uint r0, r1, r2, r3;\n  uint b0, b1, b2, b3;\n  uint g0, g1, g2, g3;\n  uint8 r8, g8, b8;\n  __global uchar *r, *g, *b;\n  uint8 av;\n  uint8 cv;\n  __global uint8 *p8;\n  __global uint8 *tbl8;\n  uint pb1, pbegin, col;\n  uint8 abuf = (uint8){amask, amask, amask, amask, amask, amask, amask, amask};\n\n  tbl8 = (__global uint8 *)table;\n\n\n\n  ww = w >> 3;\n  if(multithread != 0){\n      t = get_global_size(0);\n      gid = get_global_id(0);\n      col = ww * h;\n      pbegin = (gid * col) / t; \n      pb1 = ((gid + 1) * col) / t;\n      if(pb1 > col) {\n         ww = col - pbegin;\n      } else {\n         ww = pb1 - pbegin;\n      }\n      addr = pbegin; \n      addr2 = pbegin << 3;\n  } else {\n      addr = addr2 = 0;\n      ww = ww * h;\n  }\n  \n  p8 = (__global uint8 *)(&(out[addr2]));\n  src = &src[addr];\n  prefetch(&src[0], ww);\n  prefetch(&src[0x2000], ww);\n  prefetch(&src[0x4000], ww);\n  prefetch(&src[0x6000], ww);\n  prefetch(&src[0      + ofset], ww);\n  prefetch(&src[0x2000 + ofset], ww);\n  prefetch(&src[0x4000 + ofset], ww);\n  prefetch(&src[0x6000 + ofset], ww);\n  prefetch(&src[0      + ofset << 1], ww);\n  prefetch(&src[0x2000 + ofset << 1], ww);\n  prefetch(&src[0x4000 + ofset << 1], ww);\n  prefetch(&src[0x6000 + ofset << 1], ww);\n  prefetch(pal, 4096);\n  prefetch(tbl8, 0xc00);\n  for(x = 0; x < ww; x++) {\n        b = &src[0];\n	r = &src[ofset];\n	g = &src[ofset << 1];\n	b3 = (uint)(b[0x0    ]) + 0x300;\n	b2 = (uint)(b[0x2000]) + 0x200;\n	b1 = (uint)(b[0x4000]) + 0x100;\n	b0 = (uint)(b[0x6000]) + 0x000;\n	\n	b8 =  tbl8[b0] | tbl8[b1] | tbl8[b2] | tbl8[b3];\n\n	r3 = (uint)(r[0x0    ]) + 0x700;\n	r2 = (uint)(r[0x2000]) + 0x600;\n	r1 = (uint)(r[0x4000]) + 0x500;\n	r0 = (uint)(r[0x6000]) + 0x400;\n	\n	r8 =  tbl8[r0] | tbl8[r1] | tbl8[r2] | tbl8[r3];\n\n	\n	g3 = (uint)(g[0x0     ]) + 0xb00;\n	g2 = (uint)(g[0x2000]) + 0xa00;\n	g1 = (uint)(g[0x4000]) + 0x900;\n	g0 = (uint)(g[0x6000]) + 0x800;\n	\n	g8 =  tbl8[g0] | tbl8[g1] | tbl8[g2] | tbl8[g3];\n\n	\n	cv = (b8 | r8 | g8) & (uint8){0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff};\n	av.s0 = pal[cv.s0];\n	av.s1 = pal[cv.s1];\n	av.s2 = pal[cv.s2];\n	av.s3 = pal[cv.s3];\n	av.s4 = pal[cv.s4];\n	av.s5 = pal[cv.s5];\n	av.s6 = pal[cv.s6];\n	av.s7 = pal[cv.s7];\n	\n	*p8 = putpixel(av, abuf);\n	p8++;\n        src++;\n	}\n}	\n	\n__kernel void getvram256k(__global uchar *src, int w, int h, \n                          __global uchar4 *out, __global uint *pal,\n			  __global uint *table, uint mpage,\n			  int multithread)\n{\n  int ofset = 0xc000;\n  int x;\n  int y;\n  int hh;\n  int ww;\n  int t;\n  int gid;\n  uint addr;\n  uint addr2;\n  uint r0, r1, r2, r3, r4, r5;\n  uint b0, b1, b2, b3, b4, b5;\n  uint g0, g1, g2, g3, g4, g5;\n  uint8 r8, g8, b8;\n  __global uchar *r, *g, *b;\n  uint8 av;\n  uint8 cv;\n  __global uint8 *p8;\n  __global uint8 *tbl8;\n  uint8 abuf = (uint8){amask, amask, amask, amask, amask, amask, amask, amask};\n  tbl8 = (__global uint8 *)table;\n  uint col;\n  uint pbegin, pb1;\n\n\n  \n  ww = w >> 3;\n  if(multithread != 0){\n      t = get_global_size(0);\n      gid = get_global_id(0);\n      col = ww * h;\n      pbegin = (gid * col) / t; \n      pb1 = ((gid + 1) * col) / t;\n      if(pb1 > col) {\n         ww = col - pbegin;\n      } else {\n         ww = pb1 - pbegin;\n      }\n      addr = pbegin; \n      addr2 = pbegin << 3;\n  } else {\n      addr = addr2 = 0;\n      ww = ww * h;\n  }\n  \n  p8 = (__global uint8 *)(&(out[addr2]));\n  src = &src[addr];\n  prefetch(&src[0], ww);\n  prefetch(&src[0x2000], ww);\n  prefetch(&src[0x4000], ww);\n  prefetch(&src[0x6000], ww);\n  prefetch(&src[0x8000], ww);\n  prefetch(&src[0xa000], ww);\n  prefetch(&src[0      + ofset], ww);\n  prefetch(&src[0x2000 + ofset], ww);\n  prefetch(&src[0x4000 + ofset], ww);\n  prefetch(&src[0x6000 + ofset], ww);\n  prefetch(&src[0x8000 + ofset], ww);\n  prefetch(&src[0xa000 + ofset], ww);\n  prefetch(&src[0      + ofset << 1], ww);\n  prefetch(&src[0x2000 + ofset << 1], ww);\n  prefetch(&src[0x4000 + ofset << 1], ww);\n  prefetch(&src[0x6000 + ofset << 1], ww);\n  prefetch(&src[0x8000 + ofset << 1], ww);\n  prefetch(&src[0xa000 + ofset << 1], ww);\n  prefetch(tbl8, 0x500);\n  for(x = 0; x < ww; x++) {\n        b = &src[addr];\n	r = &src[addr + ofset];\n	g = &src[addr + ofset + ofset];\n	\n	if(!(mpage & 0x10)) {\n	    b5 = (uint)(b[0     ]) + 0x500;\n	    b4 = (uint)(b[0x2000]) + 0x400;\n	    b3 = (uint)(b[0x4000]) + 0x300;\n	    b2 = (uint)(b[0x6000]) + 0x200;\n	    b1 = (uint)(b[0x8000]) + 0x100;\n	    b0 = (uint)(b[0xa000]) + 0x000;\n	    b8 =  tbl8[b0] | tbl8[b1] | tbl8[b2] | tbl8[b3] | tbl8[b4] | tbl8[b5];\n#if __ENDIAN_LITTLE__\n            b8 <<= 18; // 6bit -> 8bit\n#else\n            b8 <<= 10; // 6bit -> 8bit\n#endif\n	} else {\n	    //b5 = b4 = b3 = b2 = b1 = b0 = 0;\n	    b8 = (uint8){0, 0, 0, 0, 0, 0, 0, 0};\n	}\n	if(!(mpage & 0x20)) {\n	    r5 = (uint)(r[0     ]) + 0x500;\n	    r4 = (uint)(r[0x2000]) + 0x400;\n	    r3 = (uint)(r[0x4000]) + 0x300;\n	    r2 = (uint)(r[0x6000]) + 0x200;\n	    r1 = (uint)(r[0x8000]) + 0x100;\n	    r0 = (uint)(r[0xa000]) + 0x000;\n	    r8 =  tbl8[r0] | tbl8[r1] | tbl8[r2] | tbl8[r3] | tbl8[r4] | tbl8[r5];\n#if __ENDIAN_LITTLE__\n            r8 <<= 2; // 6bit -> 8bit\n#else\n            r8 <<= 26; // 6bit -> 8bit\n#endif\n	} else {\n	    //b5 = b4 = b3 = b2 = b1 = b0 = 0;\n	    r8 = (uint8){0, 0, 0, 0, 0, 0, 0, 0};\n	}\n\n	if(!(mpage & 0x40)) {\n	    g5 = (uint)(g[0     ]) + 0x500;\n	    g4 = (uint)(g[0x2000]) + 0x400;\n	    g3 = (uint)(g[0x4000]) + 0x300;\n	    g2 = (uint)(g[0x6000]) + 0x200;\n	    g1 = (uint)(g[0x8000]) + 0x100;\n	    g0 = (uint)(g[0xa000]) + 0x000;\n	    g8 =  tbl8[g0] | tbl8[g1] | tbl8[g2] | tbl8[g3] | tbl8[g4] | tbl8[g5];\n#if __ENDIAN_LITTLE__\n            g8 <<= 10; // 6bit -> 8bit\n#else\n            g8 <<= 18; // 6bit -> 8bit\n#endif\n	} else {\n	    //b5 = b4 = b3 = b2 = b1 = b0 = 0;\n	    g8 = (uint8){0, 0, 0, 0, 0, 0, 0, 0};\n	}\n	\n\n	\n	cv = b8 | r8 | g8 ;\n	*p8 = putpixel(cv, abuf);\n	p8++;\n        addr++;\n	}\n}	\n	\n";
